# 基于密码的鉴权

让我们从理论到实践：如何实现身份验证?

在我们提到的三种方法中，密码验证看起来是最简单的。

我们应该如何将用户名和密码传递给 API?

## 基本鉴权

我们可以使用“基本”身份验证方案，这是互联网工程任务组 (IETF) 在 RFC 2617 中定义的标准，后来由 RFC 7617 更新。

API 必须在传入请求中查找授权标头，其结构如下：
`Authorization: Basic <encoded credentials>`
其中 `<encoded credentials>` 是 `{username}:{password}` 的 base64 编码。

根据规范，我们需要将 API 划分为多个保护空间或域 -
同一域内的资源使用相同的身份验证方案和凭证集进行保护。
我们只需要保护一个端点 - `POST /newsletters`。因此，我们将使用一个名为 `publish` 的域。
API 必须拒绝所有缺少标头或使用无效凭证的请求 - 响应必须使用 `401 Unauthorized` 状态码，并包含一个包含质询的特殊标头 `WWW-Authenticate`。

挑战是一个字符串，用于向 API 调用者解释我们期望在相关领域看到哪种类型的身份验证方案。

在我们的例子中，使用基本身份验证，它应该是:

```text
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Basic realm="publish"
```

让我们来实现它!

### 提取凭证

从传入请求中提取用户名和密码
将是我们的第一个里程碑。

让我们先从一个不太愉快的情况开始——没有 `Authorization` 标头的传入请求被拒绝。

```rs
//! tests/api/newsletter.rs
// [...]

#[tokio::test]
async fn requests_missing_authorization_are_rejected() {
    // Arrange
    let app = spawn_app().await;

    let response = reqwest::Client::new()
        .post(&format!("{}/newsletters", &app.address))
        .json(&serde_json::json!({
            "title": "Newsletter title",
            "content": {
                "text": "Newsletter body as plain text",
                "html": "<p>Newsletter body as HTML</p>",
            }
        }))
        .send()
            .await
            .expect("Failed to execute request.");

    // Assert
    assert_eq!(401, response.status().as_u16());
    assert_eq!(r#"Basic realm="publish""#, response.headers()["WWW-Authenticate"]);
}
```

它在第一个断言时就失败了:

```text
thread 'newsletter::requests_missing_authorization_are_rejected' panicked at tes
ts/api/newsletter.rs:158:5:
assertion `left == right` failed
  left: 401
 right: 200
```

我们必须更新处理程序以满足新的要求。

我们可以使用 `HttpRequest` 提取器来获取与传入请求关联的标头:

```rs
//! src/routes/newsletters.rs
// [...]
pub async fn publish_newsletter(
    body: web::Json<BodyData>,
    pool: web::Data<PgPool>,
    email_client: web::Data<EmailClient>,
    request: HttpRequest,
) -> Result<HttpResponse, PublishError> {
    let _credentials = basic_authentication(request.headers());
    // [...]
}

struct Credentials {
    username: String,
    password: SecretString,
}

fn basic_authentication(headers: &HeaderMap) -> Result<Credentials, anyhow::Error> {
    todo!()
}
```

要提取凭证，我们需要处理 base64 编码。
让我们将 `base64` crate 添加为依赖项:

```shell
cargo add base64
```

现在我们可以写下 `basic_authentication` 的主体:

```rs
//! src/routes/newsletters.rs
// [...]

fn basic_authentication(headers: &HeaderMap) -> Result<Credentials, anyhow::Error> {
    // The header value, if present, must be a valid UTF8 string
    let header_value = headers
        .get("Authorization")
        .context("The 'Authorization' header was missing")?
        .to_str()
        .context("The 'Authorization' header was not a valid UTF8 string.")?;
    let base64_encoded_segment = header_value
        .strip_prefix("Basic ")
        .context("The authorization scheme was not 'Basic'.")?;
    let decoded_bytes = base64::engine::general_purpose::STANDARD
        .decode(base64_encoded_segment)
        .context("Failed to base64-decode 'Basic' credentials.")?;
    let decoded_credentials = String::from_utf8(decoded_bytes)
        .context("The decoded credential string is not valid UTF8.")?;

    // APlit into two segments, using ':' as delimitator
    let mut credentials = decoded_credentials.splitn(2, ':');
    let username = credentials
        .next()
        .ok_or_else(|| anyhow::anyhow!("A useranme must be provided in 'Basic' auth."))?
        .to_string();
    let password = credentials
        .next()
        .ok_or_else(|| anyhow::anyhow!("A password must be provided in 'Basic' auth."))?
        .to_string();

    Ok(Credentials {
        username,
        password: SecretString::from(password),
    })
}
```

花点时间逐行检查代码，彻底理解发生了什么。很多操作都可能出错!

把 RFC 和书放在一起打开，会很有帮助!

我们还没完——我们的测试仍然失败。

我们需要根据 `basic_authentication` 返回的错误采取行动:

```rs
//! src/routes/newsletters.rs
// [...]
#[derive(thiserror::Error)]
pub enum PublishError {
    // New error variant!
    #[error("Authentication failed.")]
    AuthError(#[source] anyhow::Error),
    #[error(transparent)]
    UnexpectedError(#[from] anyhow::Error),
}


impl ResponseError for PublishError {
    fn status_code(&self) -> actix_web::http::StatusCode {
        match self {
            PublishError::AuthError(_) => StatusCode::UNAUTHORIZED,
            // Return a 401 for auth errors
            PublishError::UnexpectedError(_) => StatusCode::INTERNAL_SERVER_ERROR,
        }
    }
}

pub async fn publish_newsletter(
    // [...]
) -> Result<HttpResponse, PublishError> {
    let _credentials = basic_authentication(request.headers())
        // Bubble up the error, performing the necessary conversion
        .map_err(PublishError::AuthError)?;
    // [...]
}
```

我们的状态代码断言现在很满意，但标头断言还不满意:

```text
thread 'newsletter::requests_missing_authorization_are_rejected' panicked at tes
ts/api/newsletter.rs:159:62:
no entry found for key "WWW-Authenticate"
```

到目前为止，指定每个错误返回的状态码已经足够了——现在我们需要更多的东西，一个报头。

我们需要将重点从 `ResponseError::status_code` 转移到 `ResponseError::error_response`:

```rs
//! src/routes/newsletters.rs
// [...]
impl ResponseError for PublishError {
    fn error_response(&self) -> HttpResponse<actix_web::body::BoxBody> {
        match self {
            PublishError::UnexpectedError(_) => {
                HttpResponse::new(StatusCode::INTERNAL_SERVER_ERROR)
            }
            PublishError::AuthError(_) => {
                let mut response = HttpResponse::new(StatusCode::UNAUTHORIZED);
                let header_value = HeaderValue::from_str(r#"Basic realm="publish""#)
                    .unwrap();
                response
                    .headers_mut()
                    // actix_web::http::header provides a collection of constants
                    // for the names of several well-known/standard HTTP headers
                    .insert(header::WWW_AUTHENTICATE, header_value);
                response
            },
        }   
    }
    // `status_code` is invoked by the default `error_response`
    // implementation. We are providing a bespoke `error_response` implementation
    // therefore there is no need to maintain a `status_code` implementation anymore.
}
```

我们的身份验证测试通过了!

不过，一些旧测试还是有问题:

```text
thread 'newsletter::newsletters_are_not_delivered_to_unconfirmed_subscribers' pa
nicked at tests/api/newsletter.rs:34:5:
assertion `left == right` failed
  left: 401
 right: 200

thread 'newsletter::newsletters_are_delivered_to_confirmed_subscribers' panicked at tests/api/newsl
etter.rs:102:5:
assertion `left == right` failed
  left: 401
 right: 200
```

`POST /newsletters` 现在会拒绝所有未经身份验证的请求，包括我们在快乐路径黑盒测试中发出的请求。

我们可以通过提供随机的用户名和密码组合来阻止这种情况:

```rs
//! tests/api/helpers.rs
// [...]
impl TestApp {
    pub async fn post_newsletters(&self, body: serde_json::Value) -> reqwest::Response {
        reqwest::Client::new()
            .post(&format!("{}/newsletters", &self.address))
            // Random credentials!
            // `reqwest` does all the encoding/formatting heavy-lefting for us.
            .basic_auth(Uuid::new_v4().to_string(), Some(Uuid::new_v4().to_string()))
            .json(&body)
            .send()
            .await
            .expect("Failed to execute request.")
    }

    // [...]
}
```

测试套件应该再次通过。

## 密码验证 - 简单方法

接受随机凭证的身份验证层...并不理想。

我们需要开始验证从授权标头中提取的凭证——它们
应该与已知用户列表进行比较。

我们将创建一个新的用户 Postgres 表来存储此列表:

```shell
sqlx migrate add create_users_table
```

该模式的初稿可能如下所示:

```sql
-- migrations/<date>_create_users_table.sql
CREATE TABLE users(
  user_id uuid PRIMARY KEY,
  username TEXT NOT NULL UNIQUE,
  password TEXT NOT NULL
);
```

然后我们可以更新我们的处理程序以便在每次执行身份验证时查询它:

```rs
//! src/routes/newsletters.rs
use secrecy::ExposeSecret;
// [...]

async fn validate_credentials(
    credentials: Credentials,
    pool: &PgPool,
) -> Result<uuid::Uuid, PublishError> {
    let user_id: Option<_> = sqlx::query!(
        r#"
        SELECT user_id
        FROM users
        WHERE username = $1 AND password = $2
        "#,
        credentials.username,
        credentials.password.expose_secret()
    )
        .fetch_optional(pool)
        .await
        .context("Failed to perform a query to validate auth credentials.")
        .map_err(PublishError::UnexpectedError)?;

    user_id
        .map(|row| row.user_id)
        .ok_or_else(|| anyhow::anyhow!("Invalid username or password."))
        .map_err(PublishError::AuthError)
}

pub async fn publish_newsletter(
    body: web::Json<BodyData>,
    pool: web::Data<PgPool>,
    email_client: web::Data<EmailClient>,
    request: HttpRequest,
) -> Result<HttpResponse, PublishError> {
    let credentials = basic_authentication(request.headers())
        // Bubble up the error, performing the necessary conversion
        .map_err(PublishError::AuthError)?;
    let user_id = validate_credentials(credentials, &pool).await?;
    // [...]
}
```

记录谁调用了 `POST /newsletters` 是个好主意——让我们在处理程序周围添加一个 tracing span:

```rs
//! src/routes/newsletters.rs
// [...]

#[tracing::instrument(
    name = "Publish a newsletter issue",
    skip(body, pool, email_client, request),
    fields(username=tracing::field::Empty, user_id=tracing::field::Empty)
)]
pub async fn publish_newsletter(
    body: web::Json<BodyData>,
    pool: web::Data<PgPool>,
    email_client: web::Data<EmailClient>,
    request: HttpRequest,
) -> Result<HttpResponse, PublishError> {
    let credentials = basic_authentication(request.headers())
        // Bubble up the error, performing the necessary conversion
        .map_err(PublishError::AuthError)?;
    tracing::Span::current().record(
        "username", 
        &tracing::field::display(&credentials.username)
    );
    let user_id = validate_credentials(credentials, &pool)
        .await?;
    tracing::Span::current().record("user_id", &tracing::field::display(user_id));
    // [...]
}
```

现在，我们需要更新我们的快乐路径测试，以指定一个能被 `validate_credentials` 接受的用户名-密码对。

我们将为测试应用的每个实例生成一个测试用户。我们尚未实现新闻通讯编辑者的注册流程，因此我们无法采用完全黑盒的方法——目前，我们将把测试用户的详细信息直接注入数据库:

```rs
//! tests/api/helpers.rs
// [...]

pub async fn spawn_app() -> TestApp {
    // [...]

    let test_app = TestApp {
        // [...]
    };
    add_test_user(&test_app.db_pool).await;
    test_app
}

async fn add_test_user(pool: &PgPool) {
    sqlx::query!(
        "INSERT INTO users (user_id, username, password)
        VALUES ($1, $2, $3)",
        Uuid::new_v4(),
        Uuid::new_v4().to_string(),
        Uuid::new_v4().to_string(),
    )
    .execute(pool)
    .await
    .expect("Failed to create test users.");
}
```

`TestApp` 将提供一个辅助方法来检索其用户名和密码

```rs
//! tests/api/helpers.rs
// [...]

impl TestApp {
    // [...]
    pub async fn test_user(&self) -> (String, String) {
        let row = sqlx::query!("SELECT username, password FROM users LIMIT 1",)
            .fetch_one(&self.db_pool)
            .await
            .expect("Failed to create test users.");
        (row.username, row.password)
    }
}
```

然后我们将从您的 `post_newsletters` 方法中调用它，而不是使用随机凭据:

```rs
//! tests/api/helpers.rs
// [...]

impl TestApp {
    // [...]
    pub async fn post_newsletters(&self, body: serde_json::Value) -> reqwest::Response {
        let (username, password) = self.test_user().await;
        reqwest::Client::new()
            .post(&format!("{}/newsletters", &self.address))
            .basic_auth(username, Some(password))
            .json(&body)
            .send()
            .await
            .expect("Failed to execute request.")
    }
}
```

现在所有测试应该都可以通过了
