# 基于密码的鉴权

让我们从理论到实践：如何实现身份验证?

在我们提到的三种方法中，密码验证看起来是最简单的。

我们应该如何将用户名和密码传递给 API?

## 基本鉴权

我们可以使用“基本”身份验证方案，这是互联网工程任务组 (IETF) 在 RFC 2617 中定义的标准，后来由 RFC 7617 更新。

API 必须在传入请求中查找授权标头，其结构如下：
`Authorization: Basic <encoded credentials>`
其中 `<encoded credentials>` 是 `{username}:{password}` 的 base64 编码。

根据规范，我们需要将 API 划分为多个保护空间或域 -
同一域内的资源使用相同的身份验证方案和凭证集进行保护。
我们只需要保护一个端点 - `POST /newsletters`。因此，我们将使用一个名为 `publish` 的域。
API 必须拒绝所有缺少标头或使用无效凭证的请求 - 响应必须使用 `401 Unauthorized` 状态码，并包含一个包含质询的特殊标头 `WWW-Authenticate`。

挑战是一个字符串，用于向 API 调用者解释我们期望在相关领域看到哪种类型的身份验证方案。

在我们的例子中，使用基本身份验证，它应该是:

```text
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Basic realm="publish"
```

让我们来实现它!

### 提取凭证

从传入请求中提取用户名和密码
将是我们的第一个里程碑。

让我们先从一个不太愉快的情况开始——没有 `Authorization` 标头的传入请求被拒绝。

```rs
//! tests/api/newsletter.rs
// [...]

#[tokio::test]
async fn requests_missing_authorization_are_rejected() {
    // Arrange
    let app = spawn_app().await;

    let response = reqwest::Client::new()
        .post(&format!("{}/newsletters", &app.address))
        .json(&serde_json::json!({
            "title": "Newsletter title",
            "content": {
                "text": "Newsletter body as plain text",
                "html": "<p>Newsletter body as HTML</p>",
            }
        }))
        .send()
            .await
            .expect("Failed to execute request.");

    // Assert
    assert_eq!(401, response.status().as_u16());
    assert_eq!(r#"Basic realm="publish""#, response.headers()["WWW-Authenticate"]);
}
```

它在第一个断言时就失败了:

```text
thread 'newsletter::requests_missing_authorization_are_rejected' panicked at tes
ts/api/newsletter.rs:158:5:
assertion `left == right` failed
  left: 401
 right: 200
```

我们必须更新处理程序以满足新的要求。

我们可以使用 `HttpRequest` 提取器来获取与传入请求关联的标头:

```rs
//! src/routes/newsletters.rs
// [...]
pub async fn publish_newsletter(
    body: web::Json<BodyData>,
    pool: web::Data<PgPool>,
    email_client: web::Data<EmailClient>,
    request: HttpRequest,
) -> Result<HttpResponse, PublishError> {
    let _credentials = basic_authentication(request.headers());
    // [...]
}

struct Credentials {
    username: String,
    password: SecretString,
}

fn basic_authentication(headers: &HeaderMap) -> Result<Credentials, anyhow::Error> {
    todo!()
}
```

要提取凭证，我们需要处理 base64 编码。
让我们将 `base64` crate 添加为依赖项:

```shell
cargo add base64
```

现在我们可以写下 `basic_authentication` 的主体:

```rs
//! src/routes/newsletters.rs
// [...]

fn basic_authentication(headers: &HeaderMap) -> Result<Credentials, anyhow::Error> {
    // The header value, if present, must be a valid UTF8 string
    let header_value = headers
        .get("Authorization")
        .context("The 'Authorization' header was missing")?
        .to_str()
        .context("The 'Authorization' header was not a valid UTF8 string.")?;
    let base64_encoded_segment = header_value
        .strip_prefix("Basic ")
        .context("The authorization scheme was not 'Basic'.")?;
    let decoded_bytes = base64::engine::general_purpose::STANDARD
        .decode(base64_encoded_segment)
        .context("Failed to base64-decode 'Basic' credentials.")?;
    let decoded_credentials = String::from_utf8(decoded_bytes)
        .context("The decoded credential string is not valid UTF8.")?;

    // APlit into two segments, using ':' as delimitator
    let mut credentials = decoded_credentials.splitn(2, ':');
    let username = credentials
        .next()
        .ok_or_else(|| anyhow::anyhow!("A useranme must be provided in 'Basic' auth."))?
        .to_string();
    let password = credentials
        .next()
        .ok_or_else(|| anyhow::anyhow!("A password must be provided in 'Basic' auth."))?
        .to_string();

    Ok(Credentials {
        username,
        password: SecretString::from(password),
    })
}
```

花点时间逐行检查代码，彻底理解发生了什么。很多操作都可能出错!

把 RFC 和书放在一起打开，会很有帮助!

我们还没完——我们的测试仍然失败。

我们需要根据 `basic_authentication` 返回的错误采取行动:

```rs
//! src/routes/newsletters.rs
// [...]
#[derive(thiserror::Error)]
pub enum PublishError {
    // New error variant!
    #[error("Authentication failed.")]
    AuthError(#[source] anyhow::Error),
    #[error(transparent)]
    UnexpectedError(#[from] anyhow::Error),
}


impl ResponseError for PublishError {
    fn status_code(&self) -> actix_web::http::StatusCode {
        match self {
            PublishError::AuthError(_) => StatusCode::UNAUTHORIZED,
            // Return a 401 for auth errors
            PublishError::UnexpectedError(_) => StatusCode::INTERNAL_SERVER_ERROR,
        }
    }
}

pub async fn publish_newsletter(
    // [...]
) -> Result<HttpResponse, PublishError> {
    let _credentials = basic_authentication(request.headers())
        // Bubble up the error, performing the necessary conversion
        .map_err(PublishError::AuthError)?;
    // [...]
}
```

我们的状态代码断言现在很满意，但标头断言还不满意:

```text
thread 'newsletter::requests_missing_authorization_are_rejected' panicked at tes
ts/api/newsletter.rs:159:62:
no entry found for key "WWW-Authenticate"
```

到目前为止，指定每个错误返回的状态码已经足够了——现在我们需要更多的东西，一个报头。

我们需要将重点从 `ResponseError::status_code` 转移到 `ResponseError::error_response`:

```rs
//! src/routes/newsletters.rs
// [...]
// TODO: WIP
```
