# 登录

让我们开始处理登录表单。

我们需要连接一个端点占位符，就像之前对 GET / 所做的那样。我们将在 GET /login 中提供登录表单。

```rs
//! src/routes.rs
// [...]

// New module!
mod login;

pub use login::*;
```

```rs
//! src/routes/login.rs
mod get;

pub use get::login_form;
```

```rs
//! src/routes/login/get.rs
use actix_web::HttpResponse;

pub async fn login_form() -> HttpResponse {
    HttpResponse::Ok().finish()
}
```

```rs
//! src/startup.rs
// [...]
pub fn run(
    // [...]
) -> Result<Server, std::io::Error> {
    // [...]

    let server = HttpServer::new(move || {
        App::new()
            // [...]
            .route("/login", web::get().to(login_form))
            // [...]
    })
   // [...]
}
```

## HTML 表单

这次 HTML 会更加复杂:

```html
<!DOCTYPE html>
<html lang="en">

<head>
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1">
 <meta http-equiv="content-type" content="text/html; charset=utf-8">
 <title>Login</title>
</head>

<body>
 <form>
  <label>Username
   <input type="text" placeholder="Enter Username" name="username">
  </label>
  <label>Password
   <input type="password" placeholder="Enter password" name="password">
  </label>

  <button type="submit">Login</button>
 </form>
</body>
</html>
```

```rs
//! src/routes/login/get.rs
use actix_web::{HttpResponse, http::header::ContentType};

pub async fn login_form() -> HttpResponse {
    HttpResponse::Ok()
        .content_type(ContentType::html())
        .body(include_str!("login.html"))
}
```

form 是执行繁重工作的 HTML 元素。它的作用是收集一组数据字段，并将它们发送到后端服务器进行处理。

这些字段使用 `input` 元素定义——这里有两个: 用户名和密码。

输入元素被赋予 [type](https://www.w3schools.com/html/html_form_input_types.asp) 属性——它告诉浏览器如何显示它们。

`text` 和 `password` 都将呈现为单行自由文本字段，但有一个关键区别:

输入到密码字段的字符会被混淆。

每个输入元素都包裹在一个 label 元素中:

- 点击标签名称可切换输入字段
- 它提高了屏幕阅读器用户的可访问性（当用户将焦点放在元素上时，会大声读出）。

我们为每个输入元素设置了另外两个属性:

- `placeholder`, 其值在用户开始填写表单之前在文本字段中显示为建议值；
- `name`, 我们必须在后端使用该键来识别已提交表单数据中的字段值。

表单末尾有一个按钮，它会触发将提供的输入提交到后端。

如果您输入随机的用户名和密码并尝试提交，会发生什么?

页面会刷新，输入字段会被重置——但 URL 已经改变了!

现在应该是 `localhost:8000/login?username=myusername&password=mysecretpassword`。

这是表单的默认行为—— `form` 使用 GET HTTP 动词将数据提交到它所服务的同一页面（即 /login）。这远非理想情况——正如您刚刚看到的，通过 GET 提交的表单会将所有输入数据以明文形式编码为查询参数。作为 URL 的一部分，它们最终会被存储为浏览器的导航历史记录。查询参数也会被捕获到日志中（例如，我们自己后端的 http.route 属性）。

我们真的不希望在那里存储密码或任何类型的敏感数据。

我们可以通过设置 `form` 上的 `action` 和 `method` 的值来改变这种行为:

```html
<!-- src/routes/login/login.html -->
<!-- [...] -->
<form action="/login" method="post"></form>
<!-- [...] -->
```

从技术上讲，我们可以省略 action，但默认行为的文档记录并不详尽，因此明确定义它会更清晰。

由于 `method="post"`, 输入数据将通过请求主体传递到后端，这是一个更安全的选择。

如果您尝试再次提交表单，您应该会在 POST /login 的 API 日志中看到 404 错误。让我们定义端点！

```rs
//! src/routes/login.rs
// [...]
mod post;
pub use post::login;
```

```rs
//! src/routes/login/post.rs
use actix_web::HttpResponse;

pub async fn login() -> HttpResponse {
    HttpResponse::Ok().finish()
}
```

```rs
//! src/startup.rs
use crate::routes::login;
// [...]

pub fn run(
    listener: TcpListener,
    db_pool: PgPool,
    email_client: EmailClient,
    base_url: String,
) -> Result<Server, std::io::Error> {
    // [...]

    let server = HttpServer::new(move || {
        App::new()
            // [...]
            .route("/login", web::post().to(login))
            // [...]
    })
    // [...]
}
```

## 成功后重定向

尝试重新登录：表单将消失，您将看到一个空白页面。这不是
最好的反馈方式——理想情况下，显示一条确认用户已登录的消息才是理想的。此外，如果用户尝试刷新页面，浏览器会提示他们确认是否要再次提交表单。

我们可以通过使用重定向来改善这种情况——如果身份验证成功，我们会指示浏览器导航回我们的主页。

重定向响应需要两个元素:

- 重定向状态码；
- Location 标头，设置为我们要重定向到的 URL。

所有重定向状态码都在 3xx 范围内——我们需要根据 HTTP 动词和我们想要传达的语义（例如，临时重定向还是永久重定向）选择最合适的重定向。

您可以在 [MDN Web 文档](https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections)中找到完整的指南。`303 See Other` 最适合我们的用例（表单提交后的确认页面）:

```rs
//! src/routes/login/post.rs
use actix_web::{HttpResponse, http::header::LOCATION};

pub async fn login() -> HttpResponse {
    HttpResponse::SeeOther()
        .insert_header((LOCATION, "/"))
        .finish()
}
```

提交表单后，您现在应该会看到 "Welcome to our newsletter!"。

## 处理表单数据

说实话，我们并不是在成功时重定向——我们一直在重定向。

我们需要增强登录功能，以便真正验证传入的凭据。

正如我们在第 3 章中看到的，表单数据使用 `application/x-www-form-urlencoded` 内容类型提交到后端。

我们可以使用 actix-web 的表单提取器和一个实现 `serde::Deserialize` 的结构体从传入请求中解析出它:

```rs
//! src/routes/login/post.rs
// [...]
use actix_web::{HttpResponse, http::header::LOCATION, web};
use secrecy::SecretString;

#[derive(serde::Deserialize)]
pub struct FormData {
    username: String,
    password: SecretString,
}

pub async fn login(_form: web::Form<FormData>) -> HttpResponse {
    // [...]
}
```

我们在本章前面部分构建了基于密码的身份验证的基础 - 让我们
再次看一下 POST /newsletters 处理程序中的授权码:

```rs
//! src/routes/newsletters.rs
// [...]
#[tracing::instrument(
    name = "Publish a newsletter issue",
    skip(body, pool, email_client, request),
    fields(username=tracing::field::Empty, user_id=tracing::field::Empty)
)]
pub async fn publish_newsletter(
    body: web::Json<BodyData>,
    pool: web::Data<PgPool>,
    email_client: web::Data<EmailClient>,
    request: HttpRequest,
) -> Result<HttpResponse, PublishError> {
    let credentials = basic_authentication(request.headers())
        // Bubble up the error, performing the necessary conversion
        .map_err(PublishError::AuthError)?;
    tracing::Span::current().record("username", tracing::field::display(&credentials.username));
    let user_id = validate_credentials(credentials, &pool).await?;
    tracing::Span::current().record("user_id", tracing::field::display(user_id));
    // [...]
}
```

`basic_authentication` 处理从 `Authorization` 标头中提取凭据当使用"Basic"身份验证方案时——我们不想在登录时重复使用它。

`validation_credentials` 才是我们想要的: 它以用户名和密码作为输入，返回相应的 user_id（如果身份验证成功）或错误（如果凭据无效）。

`validation_credentials` 的当前定义受到 `publish_newsletters` 关注点的影响:

```rs
//! src/routes/newsletters.rs
// [...]

async fn validate_credentials(
    credentials: Credentials,
    pool: &PgPool,
) -> Result<uuid::Uuid, PublishError> {
    let mut user_id = None;
    let mut expected_password_hash = SecretString::from(
        "$argon2id$v=19$m=15000,t=2,p=1$\
gZiV/M1gPc22ElAH/Jh1Hw$\
CWOrkoo7oJBQ/iyh7uJ0LO2aLEfrHwTWllSAxT0zRno"
            .to_string(),
    );
    if let Some((stored_user_id, stored_password_hash)) =
        get_stored_credentials(&credentials.username, pool)
            .await
            .map_err(PublishError::UnexpectedError)?
    {
        user_id = Some(stored_user_id);
        expected_password_hash = stored_password_hash
    }

    spawn_blocking_with_tracing(move || {
        verify_password_hash(expected_password_hash, credentials.password)
    })
    .await
    .context("Invalid password")
    .map_err(PublishError::AuthError)??;

    user_id.ok_or_else(|| PublishError::AuthError(anyhow::anyhow!("Unknown username.")))
}
```

### 构建一个 `authentication` 模块

让我们重构 `validate_credentials`, 以便为提取做好准备——我们想要构建一个共享的身份验证模块，它将在
`POST /login` 和 `POST /newsletters` 中同时使用。
让我们定义一个新的错误枚举 `AuthError`:

```rs
//! src/lib.rs
pub mod authentication;
```

```rs
//! src/authentication.rs
#[derive(thiserror::Error, Debug)]
pub enum AuthError {
    #[error("Invalid credentials.")]
    InvalidCredentials(#[source] anyhow::Error),
    #[error(transparent)]
    UnexpectedError(#[from] anyhow::Error),
}
```

我们使用枚举，是因为就像我们在 `POST /newsletters` 中所做的那样, 我们希望能够让调用者根据错误类型做出不同的响应 - 例如，对于 `UnexpectedError` 返回 500，而对于 `AuthErrors` 则返回 401。

现在，让我们将 `validate_credentials` 的签名更改为返回 `Result<uuid::Uuid, AuthError>`:

```rs
//! src/routes/newsletters.rs
usae crate::authentication::AuthError;
// [...]

async fn validate_credentials(
    credentials: Credentials,
    pool: &PgPool,
) -> Result<uuid::Uuid, AuthError> {
    let mut user_id = None;
    let mut expected_password_hash = SecretString::from(
        "$argon2id$v=19$m=15000,t=2,p=1$\
gZiV/M1gPc22ElAH/Jh1Hw$\
CWOrkoo7oJBQ/iyh7uJ0LO2aLEfrHwTWllSAxT0zRno"
            .to_string(),
    );
    if let Some((stored_user_id, stored_password_hash)) =
        get_stored_credentials(&credentials.username, pool).await?
    {
        user_id = Some(stored_user_id);
        expected_password_hash = stored_password_hash
    }

    spawn_blocking_with_tracing(move || {
        verify_password_hash(expected_password_hash, credentials.password)
    })
    .await
    .context("Invalid password")??;

    user_id
        .ok_or_else(|| anyhow::anyhow!("Unknown username."))
        .map_err(AuthError::InvalidCredentials)
}
```

`cargo check` 返回了两个错误

```text
error[E0277]: `?` couldn't convert the error to `PublishError`
  --> src/routes/newsletters.rs:85:65
   |
85 |     let user_id = validate_credentials(credentials, &pool).await?;
   |                   ----------------------------------------------^ the trait `std::convert::Fro
m<AuthError>` is not implemented for `PublishError`
   |                   |
   |                   this can't be annotated with `?` because it has type `Result<_, AuthError>`
   |
error[E0277]: `?` couldn't convert the error to `AuthError`
   --> src/routes/newsletters.rs:206:34
    |
202 | /     spawn_blocking_with_tracing(move || {
203 | |         verify_password_hash(expected_password_hash, credentials.password)
204 | |     })
205 | |     .await
206 | |     .context("Invalid password")??;
    | |                                 -^ the trait `std::convert::From<PublishError>` is not impl
emented for `AuthError`
    | |_________________________________|
    |                                   this can't be annotated with `?` because it has type `Resul
t<_, PublishError>`
    |
```

第一个错误来自 `validate_credentials` 本身——我们正在调用 `verify_password_hash`, 它仍然返回 `PublishError`。

```rs
//! src/routes/newsletters.rs
// [...]

fn verify_password_hash(
    expected_password_hash: SecretString,
    password_candidate: SecretString,
) -> Result<(), PublishError> {
    let expected_password_hash = PasswordHash::new(expected_password_hash.expose_secret())
        .context("Failed to parse hash in PHC string format.")
        .map_err(PublishError::UnexpectedError)?;

    Argon2::default()
        .verify_password(
            password_candidate.expose_secret().as_bytes(),
            &expected_password_hash,
        )
        .context("Invalid password.")
        .map_err(PublishError::AuthError)
}
```

让我们修正它:

```rs
//! src/routes/newsletters.rs
// [...]

fn verify_password_hash(
    expected_password_hash: SecretString,
    password_candidate: SecretString,
) -> Result<(), AuthError> {
    let expected_password_hash = PasswordHash::new(expected_password_hash.expose_secret())
        .context("Failed to parse hash in PHC string format.")?;

    Argon2::default()
        .verify_password(
            password_candidate.expose_secret().as_bytes(),
            &expected_password_hash,
        )
        .context("Invalid password.")
        .map_err(AuthError::InvalidCredentials)
}
```

让我们处理第二个错误:

```text
  --> src/routes/newsletters.rs:85:65
   |
85 |     let user_id = validate_credentials(credentials, &pool).await?;
   |                   ----------------------------------------------^ the trait `std::convert::Fro
m<AuthError>` is not implemented for `PublishError`
   |                   |
   |                   this can't be annotated with `?` because it has type `Result<_, AuthError>`
   |
```

这源于在请求处理程序 `publish_newsletters` 中对 `verify_credentials` 的调用。
`AuthError` 未实现到 `PublishError` 的转换，因此无法使用 ? 运算符。

我们将调用 `map_err` 来内联执行映射:

```rs
//! src/routes/newsletters.rs
// [...]
pub async fn publish_newsletter(
    body: web::Json<BodyData>,
    pool: web::Data<PgPool>,
    email_client: web::Data<EmailClient>,
    request: HttpRequest,
) -> Result<HttpResponse, PublishError> {
    // [...]
    let user_id = validate_credentials(credentials, &pool)
        .await
        // We match on `AuthError`'s variants, bit we pass the **whole** error
        // into the constructors for `PublishError` variants. This ensures that
        // the context of the top-level wrapped is preserved when the error is
        // logged by our middleware.
        .map_err(|e| match e {
            AuthError::InvalidCredentials(_) => PublishError::AuthError(e.into()),
            AuthError::UnexpectedError(_) => PublishError::UnexpectedError(e.into()),
        })?;
    // [...]
}
```

现在代码应该可以编译通过了

让我们通过将 `validate_credentials`、`Credentials`、`get_stored_credentials`
和 `verify_password_hash` 移到 `authentication` 模块来完成提取:

```rs
//! src/authentication.rs
use anyhow::Context;
use argon2::{Argon2, PasswordHash, PasswordVerifier};
use secrecy::{ExposeSecret, SecretString};
use sqlx::PgPool;

use crate::telemetry::spawn_blocking_with_tracing;

// [...]

pub struct Credentials {
  // These two fields were not marked as `pub` before!
    pub username: String,
    pub password: SecretString,
}

#[tracing::instrument(/* */)]
pub async fn validate_credentials(/* */) -> Result<uuid::Uuid, AuthError> {
    // [...]
}

#[tracing::instrument(/* */)]
fn verify_password_hash(/* */) -> Result<(), AuthError> {
    // [...]
}

#[tracing::instrument(/* */)]
async fn get_stored_credentials(/* */) -> Result<Option<(uuid::Uuid, SecretString)>, anyhow::Error> {
    // [...]
}
```

```rs
//! src/routes/newsletters.rs
// [...]
use crate::authentication::{validate_credentials, AuthError, Credentials};
// There will be warnings about unused imports, follow the compiler to fix them!
// [...]
```

### 拒绝无效凭证

提取的 `authentication` 模块现在可以在我们的 `login` 函数中使用了。

让我们将其插入:

```rs
//! src/routes/login/post.rs
use actix_web::{HttpResponse, http::header::LOCATION, web};
use secrecy::SecretString;
use sqlx::PgPool;

use crate::authentication::{Credentials, validate_credentials};

#[derive(serde::Deserialize)]
pub struct FormData {
    username: String,
    password: SecretString,
}

#[tracing::instrument(
    skip(form, pool),
    fields(username=tracing::field::Empty, user_id=tracing::field::Empty)
)]
pub async fn login(form: web::Form<FormData>, pool: web::Data<PgPool>) -> HttpResponse {
    let credentials = Credentials {
        username: form.0.username,
        password: form.0.password,
    };
    tracing::Span::current().record("username", tracing::field::display(&credentials.username));
    match validate_credentials(credentials, &pool).await {
        Ok(user_id) => {
            tracing::Span::current().record("user_id", tracing::field::display(&user_id));
            HttpResponse::SeeOther()
                .insert_header((LOCATION, "/"))
                .finish()
        }

        Err(_) => {
            todo!()
        }
    }
}
```

使用随机凭证的登录尝试现在应该会失败：请求处理程序会因为 `validation_credentials` 返回错误而崩溃，进而导致 actix-web 断开连接。

这并非优雅的失败——浏览器可能会显示类似以下内容: 连接已重置。

我们应该尽可能避免请求处理程序中出现崩溃——所有错误都应该优雅地处理。

让我们引入一个 `LoginError`:

```rs
//! src/routes/login/post.rs
// [...]
use actix_web::{
    HttpResponse, ResponseError,
    http::{StatusCode, header::LOCATION},
    web,
};

use crate::{
    authentication::{Credentials, validate_credentials},
    routes::error_chain_fmt,
};

#[derive(serde::Deserialize)]
pub struct FormData {
    username: String,
    password: SecretString,
}

#[tracing::instrument(
    skip(form, pool),
    fields(username=tracing::field::Empty, user_id=tracing::field::Empty)
)]
pub async fn login(
    form: web::Form<FormData>,
    pool: web::Data<PgPool>,
) -> Result<HttpResponse, LoginError> {
    // [...]
    let user_id = validate_credentials(credentials, &pool)
        .await
        .map_err(|e| match e {
            AuthError::InvalidCredentials(_) => LoginError::AuthError(e.into()),
            AuthError::UnexpectedError(_) => LoginError::UnexpectedError(e.into()),
        })?;

    tracing::Span::current().record("user_id", tracing::field::display(&user_id));
    Ok(HttpResponse::SeeOther()
        .insert_header((LOCATION, "/"))
        .finish())
}


#[derive(thiserror::Error)]
pub enum LoginError {
    #[error("Authentication failed")]
    AuthError(#[source] anyhow::Error),
    #[error("Something went wrong")]
    UnexpectedError(#[from] anyhow::Error),
}

impl std::fmt::Debug for LoginError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        error_chain_fmt(self, f)
    }
}

impl ResponseError for LoginError {
    fn status_code(&self) -> actix_web::http::StatusCode {
        match self {
            LoginError::UnexpectedError(_) => StatusCode::INTERNAL_SERVER_ERROR,
            LoginError::AuthError(_) => StatusCode::UNAUTHORIZED,
        }
    }
}
```

这段代码与我们之前重构 POST /newsletters 时编写的代码非常相似。

这会对浏览器产生什么影响?

提交表单会触发页面加载，导致屏幕上显示"Authentication failed"。

比以前好多了，我们正在取得进展!

## 语境错误

错误信息已经足够清晰了——但用户接下来应该怎么做呢?

我们合理地假设他们想再次尝试输入凭证——他们可能拼错了用户名或密码。

我们需要将错误信息显示在登录表单的顶部——为用户提供信息，同时允许他们快速重试。

### 简单实现

最简单的方法是什么?

我们可以从 ResponseError 返回登录 HTML 页面，并注入一个额外的段落 (`<p>`
HTML 元素) 来向用户报告错误。

它看起来应该像这样:

```rs
//! src/routes/login/post.rs
// [...]

impl ResponseError for LoginError {
    fn status_code(&self) -> actix_web::http::StatusCode {
        // [...]
    }

    fn error_response(&self) -> HttpResponse<actix_web::body::BoxBody> {
        HttpResponse::build(self.status_code())
            .content_type(ContentType::html())
            .body(format!(
                r#"<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>Login</title>
</head>
<body>
    <p><i>{}</i></p>
    <form action="/login" method="post">
        <label>Username
        <input
            type="text"
            placeholder="Enter Username"
            name="username"
        >
        </label>
        <label>Password
            <input
            type="password"
            placeholder="Enter Password"
            name="password"
        >
        </label>
        <button type="submit">Login</button>
    </form>
</body>
</html>
            "#,
                self
            ))
    }
}
```

这种方法有几个缺点:

- 我们有两个略有不同但几乎完全相同的登录页面，定义在两个不同的地方。
  如果我们决定修改登录表单，我们需要记住同时修改这两个页面

- 如果用户在登录失败后尝试刷新页面，系统会提示用户确认是否重新提交表单。

为了解决第二个问题，我们需要让用户登录到 GET 端点。

为了解决第一个问题，我们需要找到一种方法来重用我们在 `GET /login` 中编写的 HTML, 而不是复制它。

我们可以通过另一个重定向来实现这两个目标：如果身份验证失败，我们会将用户返回到 `GET /login`。

```rs
//! src/routes/login/post.rs
// [...]
impl ResponseError for LoginError {
    fn error_response(&self) -> HttpResponse<actix_web::body::BoxBody> {
        HttpResponse::build(self.status_code())
            .insert_header((LOCATION, "/login"))
            .finish()
    }

    fn status_code(&self) -> StatusCode {
        StatusCode::SEE_OTHER
    }
}
```

不幸的是，普通的重定向是不够的——浏览器会再次向用户显示登录表单，而且没有任何反馈来解释他们的登录尝试失败。

我们需要找到一种方法来指示 GET /login 显示错误消息。

让我们来探索一些方案。

### 查询参数

Location 标头的值决定了用户将被重定向到的 URL。

但这还不够——我们还可以指定查询参数!

让我们将身份验证错误消息编码到错误查询参数中。

查询参数是 URL 的一部分——因此我们需要对 `LoginError` 的显示表示进行 URL 编码。

```toml
#! Cargo.toml
# [...]

[dependencies]
urlencoding = "2"
```

TODO: WIP
