# 登录

让我们开始处理登录表单。

我们需要连接一个端点占位符，就像之前对 GET / 所做的那样。我们将在 GET /login 中提供登录表单。

```rs
//! src/routes.rs
// [...]

// New module!
mod login;

pub use login::*;
```

```rs
//! src/routes/login.rs
mod get;

pub use get::login_form;
```

```rs
//! src/routes/login/get.rs
use actix_web::HttpResponse;

pub async fn login_form() -> HttpResponse {
    HttpResponse::Ok().finish()
}
```

```rs
//! src/startup.rs
// [...]
pub fn run(
    // [...]
) -> Result<Server, std::io::Error> {
    // [...]

    let server = HttpServer::new(move || {
        App::new()
            // [...]
            .route("/login", web::get().to(login_form))
            // [...]
    })
   // [...]
}
```

## HTML 表单

这次 HTML 会更加复杂:

```html
<!DOCTYPE html>
<html lang="en">

<head>
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1">
 <meta http-equiv="content-type" content="text/html; charset=utf-8">
 <title>Login</title>
</head>

<body>
 <form>
  <label>Username
   <input type="text" placeholder="Enter Username" name="username">
  </label>
  <label>Password
   <input type="password" placeholder="Enter password" name="password">
  </label>
 </form>
</body>
</html>
```

```rs
//! src/routes/login/get.rs
use actix_web::{HttpResponse, http::header::ContentType};

pub async fn login_form() -> HttpResponse {
    HttpResponse::Ok()
        .content_type(ContentType::html())
        .body(include_str!("login.html"))
}
```

form 是执行繁重工作的 HTML 元素。它的作用是收集一组数据字段，并将它们发送到后端服务器进行处理。

这些字段使用 `input` 元素定义——这里有两个: 用户名和密码。

输入元素被赋予 [type](https://www.w3schools.com/html/html_form_input_types.asp) 属性——它告诉浏览器如何显示它们。

`text` 和 `password` 都将呈现为单行自由文本字段，但有一个关键区别:

输入到密码字段的字符会被混淆。

每个输入元素都包裹在一个 label 元素中:

- 点击标签名称可切换输入字段
- 它提高了屏幕阅读器用户的可访问性（当用户将焦点放在元素上时，会大声读出）。

我们为每个输入元素设置了另外两个属性:

- `placeholder`, 其值在用户开始填写表单之前在文本字段中显示为建议值；
- `name`, 我们必须在后端使用该键来识别已提交表单数据中的字段值。

表单末尾有一个按钮，它会触发将提供的输入提交到后端。

如果您输入随机的用户名和密码并尝试提交，会发生什么?

页面会刷新，输入字段会被重置——但 URL 已经改变了!

现在应该是 `localhost:8000/login?username=myusername&password=mysecretpassword`。

这是表单的默认行为—— `form` 使用 GET HTTP 动词将数据提交到它所服务的同一页面（即 /login）。这远非理想情况——正如您刚刚看到的，通过 GET 提交的表单会将所有输入数据以明文形式编码为查询参数。作为 URL 的一部分，它们最终会被存储为浏览器的导航历史记录。查询参数也会被捕获到日志中（例如，我们自己后端的 http.route 属性）。

我们真的不希望在那里存储密码或任何类型的敏感数据。

我们可以通过设置 `form` 上的 `action` 和 `method` 的值来改变这种行为:

```html
<!-- src/routes/login/login.html -->
<!-- [...] -->
<form action="/login" method="post"></form>
<!-- [...] -->
```

从技术上讲，我们可以省略 action，但默认行为的文档记录并不详尽，因此明确定义它会更清晰。

由于 `method="post"`, 输入数据将通过请求主体传递到后端，这是一个更安全的选择。

如果您尝试再次提交表单，您应该会在 POST /login 的 API 日志中看到 404 错误。让我们定义端点！

```rs
//! src/routes/login.rs
// [...]
mod post;
pub use post::login;
```

```rs
//! src/routes/login/post.rs
use actix_web::HttpResponse;

pub async fn login() -> HttpResponse {
    HttpResponse::Ok().finish()
}
```

```rs
//! src/startup.rs
use crate::routes::login;
// [...]

pub fn run(
    listener: TcpListener,
    db_pool: PgPool,
    email_client: EmailClient,
    base_url: String,
) -> Result<Server, std::io::Error> {
    // [...]

    let server = HttpServer::new(move || {
        App::new()
            // [...]
            .route("/login", web::post().to(login))
            // [...]
    })
    // [...]
}
```

## 成功后重定向

TODO: WIP
