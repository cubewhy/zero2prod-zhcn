# 会话

我们花了一段时间思考登录失败后应该如何处理。现在该交换一下了: 登录成功后，我们期望看到什么?

身份验证旨在限制对需要更高权限的功能的访问——在我们的例子中，
就是向整个邮件列表发送新一期新闻通讯的功能。我们想要构建一个管理面板——我们将有一个 /admin/dashboard 页面，仅限登录用户访问，以便访问所有管理功能。

我们将分阶段实现。作为第一个里程碑，我们希望:

- 登录成功后重定向到 `/admin/dashboard`, 并显示 `欢迎 <username>!` 问候语
- 如果用户尝试直接导航到 `/admin/dashboard` 并且他们尚未登录，他们将被重定向到登录表单。

此计划需要会话。

## 基于会话的鉴权

基于会话的身份验证是一种避免在每个页面上都要求用户输入密码的策略。

用户只需通过登录表单进行一次身份验证：如果成功，服务器将生成一个一次性密钥——经过身份验证的会话令牌。

后端 API 将接受会话令牌而不是用户名/密码组合，并
授予对受限功能的访问权限。每次请求都必须提供会话令牌——
这就是会话令牌以 Cookie 形式存储的原因。浏览器将确保将 Cookie 附加到所有 API 的传出请求中。

从安全角度来看，有效的会话令牌与相应的身份验证密钥（例如用户名/密码组合、生物识别或物理第二因素）一样强大。

我们必须格外小心，避免将会话令牌暴露给攻击者。

OWASP 提供了有关如何保护会话安全的详尽指南——我们将在下一节中实施他们的大部分建议。

## 会话存储

让我们开始思考具体实现吧！

基于我们目前讨论的内容，我们需要 API 在登录成功后生成一个会话令牌。

该令牌值必须是不可预测的——我们不希望攻击者能够生成或猜测一个有效的会话令牌。OWASP 建议使用加密安全的伪随机数生成器 (CSPRNG)。

仅仅随机性是不够的——我们还需要唯一性。如果我们将两个用户关联到同一个会话令牌，就会遇到麻烦:

- 我们可能会授予其中一个用户高于其应得权限的权限
- 我们可能会泄露个人或机密信息，例如姓名、电子邮件、过往活动等。

我们需要一个**会话存储**——服务器必须记住它生成的令牌，以便授权已登录用户的未来请求。我们还希望将信息关联到每个活动会话——这被称为**会话状态**。

## 选择会话存储

在会话的生命周期中，我们需要执行以下操作:

- 创建会话，当用户登录时
- 检索会话，使用从传入请求中附加的 Cookie 中提取的会话令牌
- 更新会话，当登录用户执行某些操作导致其会话状态发生变化时
- 删除会话，当用户注销时

这些操作通常称为 CRUD（创建、删除、读取、更新）。

我们还需要某种形式的过期机制——会话应该是短暂的。如果没有清理机制，
我们最终会为过期/陈旧的会话占用比活动会话更多的空间。

### Postgres

Postgres 是否是一个可行的会话存储方案?

我们可以创建一个新的会话表，以令牌作为主索引——这是一种确保令牌唯一性的简单方法。

对于会话状态，我们有几种选择:

- “经典”关系建模，使用规范化模式（即我们存储应用程序状态的方式）
- 单个状态列，使用 jsonb 数据类型，保存键值对集合。

遗憾的是，Postgres 没有内置的行过期机制。我们必须
添加一个 `expires_at` 列，并定期触发清理作业来清除过期会话——
这有点繁琐。

### Redis

Redis 是另一种流行的会话存储方案。

Redis 是一个内存数据库——它使用内存而非磁盘进行存储，牺牲了持久性来换取速度。

它非常适合存储那些可以建模为键值对集合的数据。

它还原生支持过期时间——我们可以为所有值附加一个生存时间，Redis
会负责处理这些值。

它如何应用于会话?

我们的应用程序从不批量操作会话——我们每次只处理一个会话，
并使用其令牌进行标识。因此，我们可以使用会话令牌作为键，而值则是会话状态的 JSON
表示形式——应用程序负责序列化/反序列化。

会话的生命周期很短——无需担心使用内存而不是磁盘进行持久化，
速度提升是一个不错的附加效果!

正如您可能已经猜到的那样，我们将使用 Redis 作为会话存储后端!

## actix-session

`actix-session` 为 actix-web 应用程序提供会话管理。让我们将它添加到我们的依赖项中:

```toml
#! Cargo.toml
# [...]
[dependencies]
actix-session = "0.11.0"
# [...]
```

actix-session 中的键类型是 `SessionMiddleware` - 它负责加载会话数据、跟踪状态变化并在请求/响应生命周期结束时将其持久化。

要构建 `SessionMiddleware` 实例，我们需要提供一个存储后端和一个密钥来对会话 cookie 进行签名（或加密）。该方法与 `actix-web-flash-messages` 中的 `FlashMessagesFramework` 所使用的方法非常相似。

```rs
//! src/startup.rs
// [...]
use actix_session::SessionMiddleware;

pub fn run(
    // [...]
    hmac_secret: SecretString,
) -> Result<Server, std::io::Error> {
    // [...]

    let secret_key = Key::from(hmac_secret.expose_secret().as_bytes());
    let message_store =
        CookieMessageStore::builder(Key::from(hmac_secret.expose_secret().as_bytes())).build();
    // [...]
    let server = HttpServer::new(move || {
        App::new()
            .wrap(message_framework.clone())
            .wrap(SessionMiddleware::new(todo!(), secret_key.clone()))
            .wrap(TracingLogger::default())
            // [...]
    })
    .listen(listener)?
    .run();

    Ok(server)
}
```

actix-session 在存储方面非常灵活——您可以通过实现 `SessionStore` trait 来提供自己的存储。它还提供了一些开箱即用的实现，隐藏在一系列功能标志后面——其中包括一个 Redis 后端。让我们启用它:

```toml
#! Cargo.toml
# [...]
[dependencies]
actix-session = { version = "0.11.0", features = ["redis-session-rustls"] }
```

现在我们可以访问 `RedisSessionStore` 了。要构建一个 `RedisSessionStore`, 我们需要传入一个 Redis 连接字符串作为输入——让我们将 `redis_uri` 添加到我们的配置结构体中:

```rs
//! src/configuration.rs
// [...]
pub struct Settings {
    // [...]
    pub redis_uri: SecretString,
}
// [...]
```

```yaml
# configuration/base.yaml
# 6379 is Redis' default port
redis_uri: "redis://127.0.0.1:6379"
# [...]
```

让我们使用它来构建一个 `RedisSessionStore` 实例:

```rs
//! src/startup.rs
// [...]
impl Application {
    // Async now! We also return anyhow::Error instead of std::io::Error
    pub async fn build(configuration: Settings) -> Result<Self, anyhow::Error> {
        // [...]
        let server = run(
            // [...]
            configuration.redis_uri,
        ).await?;

        Ok(Self { port, server })
    }

    // [...]
}

// Now it's asynchronous!
async fn run(
    listener: TcpListener,
    db_pool: PgPool,
    email_client: EmailClient,
    base_url: String,
    hmac_secret: SecretString,
    redis_uri: SecretString,
// Returning anyhow::Error instead of std::io::Error
) -> Result<Server, anyhow::Error> {
    // [...]
    let redis_store = RedisSessionStore::new(redis_uri.expose_secret()).await?;
    let server = HttpServer::new(move || {
        App::new()
            .wrap(message_framework.clone())
            .wrap(SessionMiddleware::new(
                redis_store.clone(),
                secret_key.clone(),
            ))
            .wrap(TracingLogger::default())
            // [...]
    })
    // [...]
}
```

```rs
//! src/main.rs
// [...]

#[tokio::main]
// anyhow::Result now instead of std::io::Error
async fn main() -> anyhow::Result<()> {
    // [...]
}
```

是时候将正在运行的 Redis 实例添加到我们的设置中了。

### 我们开发设置中的 Redis

我们需要在 CI 管道中运行一个 Redis 容器，与 Postgres 容器一起运行——[请查看书籍存储库中更新的 YAML](https://github.com/LukeMathWalker/zero-to-production/blob/root-chapter-10-part2/.github/workflows/general.yml)。

我们还需要在开发机器上运行一个 Redis 容器来执行测试套件并启动应用程序。让我们添加一个脚本来启动它：

```shell
# scripts/init_redis.sh
#!/usr/bin/env bash
set -x
set -eo pipefail

# if a redis container is running, print instructions to kill it and exit
RUNNING_CONTAINER=$(docker ps --filter 'name=redis' --format '{{.ID}}')
if [[ -n $RUNNING_CONTAINER ]]; then
  echo >&2 "there is a redis container already running, kill it with"
  echo >&2 "
  docker kill ${RUNNING_CONTAINER}"
  exit 1
fi

# Launch Redis using Docker
docker run \
  -p "6379:6379" \
  -d \
  --name "redis_$(date '+%s')" \
  redis:8
  >&2 echo "Redis is ready to go!"
```

该脚本需要标记为可执行，然后启动:

```shell
chmod +x ./scripts/init_redis.sh
./script/init_redis.sh
```

### Digital Ocean 上的 Redis

Digital Ocean 不支持通过 spec.yaml 文件创建开发版 Redis 集群。您需要访问他们的仪表盘 - 在此处创建一个新的 Redis 集群。请务必选择您部署应用程序的数据中心。集群创建完成后，
您需要完成一个快速的“入门”流程来配置一些参数（可信源、驱逐策略等）。

在“入门”流程的最后，您将能够将连接字符串复制到新配置的 Redis 实例。连接字符串包含用户名和密码，因此我们必须将其视为机密信息。我们将使用环境变量值（在应用程序控制台的“设置”面板中设置 APP_REDIS_URI）将其值注入应用程序。
