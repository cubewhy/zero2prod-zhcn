# 会话

我们花了一段时间思考登录失败后应该如何处理。现在该交换一下了: 登录成功后，我们期望看到什么?

身份验证旨在限制对需要更高权限的功能的访问——在我们的例子中，
就是向整个邮件列表发送新一期新闻通讯的功能。我们想要构建一个管理面板——我们将有一个 /admin/dashboard 页面，仅限登录用户访问，以便访问所有管理功能。

我们将分阶段实现。作为第一个里程碑，我们希望:

- 登录成功后重定向到 `/admin/dashboard`, 并显示 `欢迎 <username>!` 问候语
- 如果用户尝试直接导航到 `/admin/dashboard` 并且他们尚未登录，他们将被重定向到登录表单。

此计划需要会话。

## 基于会话的鉴权

基于会话的身份验证是一种避免在每个页面上都要求用户输入密码的策略。

用户只需通过登录表单进行一次身份验证：如果成功，服务器将生成一个一次性密钥——经过身份验证的会话令牌。

后端 API 将接受会话令牌而不是用户名/密码组合，并
授予对受限功能的访问权限。每次请求都必须提供会话令牌——
这就是会话令牌以 Cookie 形式存储的原因。浏览器将确保将 Cookie 附加到所有 API 的传出请求中。

从安全角度来看，有效的会话令牌与相应的身份验证密钥（例如用户名/密码组合、生物识别或物理第二因素）一样强大。

我们必须格外小心，避免将会话令牌暴露给攻击者。

OWASP 提供了有关如何保护会话安全的详尽指南——我们将在下一节中实施他们的大部分建议。

## 会话存储

让我们开始思考具体实现吧！

基于我们目前讨论的内容，我们需要 API 在登录成功后生成一个会话令牌。

该令牌值必须是不可预测的——我们不希望攻击者能够生成或猜测一个有效的会话令牌。OWASP 建议使用加密安全的伪随机数生成器 (CSPRNG)。

仅仅随机性是不够的——我们还需要唯一性。如果我们将两个用户关联到同一个会话令牌，就会遇到麻烦:

- 我们可能会授予其中一个用户高于其应得权限的权限
- 我们可能会泄露个人或机密信息，例如姓名、电子邮件、过往活动等。

我们需要一个**会话存储**——服务器必须记住它生成的令牌，以便授权已登录用户的未来请求。我们还希望将信息关联到每个活动会话——这被称为**会话状态**。

## 选择会话存储

在会话的生命周期中，我们需要执行以下操作:

- 创建会话，当用户登录时
- 检索会话，使用从传入请求中附加的 Cookie 中提取的会话令牌
- 更新会话，当登录用户执行某些操作导致其会话状态发生变化时
- 删除会话，当用户注销时

这些操作通常称为 CRUD（创建、删除、读取、更新）。

我们还需要某种形式的过期机制——会话应该是短暂的。如果没有清理机制，
我们最终会为过期/陈旧的会话占用比活动会话更多的空间。

### Postgres

Postgres 是否是一个可行的会话存储方案?

我们可以创建一个新的会话表，以令牌作为主索引——这是一种确保令牌唯一性的简单方法。

对于会话状态，我们有几种选择:

- “经典”关系建模，使用规范化模式（即我们存储应用程序状态的方式）
- 单个状态列，使用 jsonb 数据类型，保存键值对集合。

遗憾的是，Postgres 没有内置的行过期机制。我们必须
添加一个 `expires_at` 列，并定期触发清理作业来清除过期会话——
这有点繁琐。

### Redis

Redis 是另一种流行的会话存储方案。

Redis 是一个内存数据库——它使用内存而非磁盘进行存储，牺牲了持久性来换取速度。

它非常适合存储那些可以建模为键值对集合的数据。

它还原生支持过期时间——我们可以为所有值附加一个生存时间，Redis
会负责处理这些值。

它如何应用于会话?

我们的应用程序从不批量操作会话——我们每次只处理一个会话，
并使用其令牌进行标识。因此，我们可以使用会话令牌作为键，而值则是会话状态的 JSON
表示形式——应用程序负责序列化/反序列化。

会话的生命周期很短——无需担心使用内存而不是磁盘进行持久化，
速度提升是一个不错的附加效果!

正如您可能已经猜到的那样，我们将使用 Redis 作为会话存储后端!

## actix-session

`actix-session` 为 actix-web 应用程序提供会话管理。让我们将它添加到我们的依赖项中:

```toml
#! Cargo.toml
# [...]
# TODO: WIP
```
